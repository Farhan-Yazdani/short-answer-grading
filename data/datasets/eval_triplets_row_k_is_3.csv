,sentence1,sentence2,label
0,To simulate the behaviour of portions of the desired software product.,To simulate portions of the desired final product with a quick and easy program that does a small specific job. It is a way to help see what the problem is and how you may solve it in the final project.,1.0
1,To simulate the behaviour of portions of the desired software product.,A prototype program simulates the behaviors of portions of the desired software product to allow for error checking.,0.8
2,To simulate the behaviour of portions of the desired software product.,A program that simulates the behavior of portions of the desired software product.,1.0
3,The testing stage can influence both the coding stage (phase 5) and the solution refinement stage (phase 7),The implementation phase and the maintenance phase are effected,0.8
4,The testing stage can influence both the coding stage (phase 5) and the solution refinement stage (phase 7),"Verification, coding, refining the solution and maintenance are all influenced by the testing stage.",0.9
5,The testing stage can influence both the coding stage (phase 5) and the solution refinement stage (phase 7),"The refining step, the production step, and the maintenance stage.  ",0.7
6,Abstraction and reusability.,"This type of programming is more flexible, making it easier to add and modify the program.  It is also a type of a fail safe program, you check each individual module.  This eliminates redundant code and makes the program easier to read for other programmers.  When debugging the program it is easier to track down the source of a problem within a module rather than a 2 million line program.",1.0
7,Abstraction and reusability.,The main advantages to object-oriented programming are that existing classes can be reused and program maintenance and verification are easier.,0.7
8,Abstraction and reusability.,"Existing classes can be reused, and program maintenance and verification are easier.",0.7
9,At the main function.,the Function main().,1.0
10,At the main function.,c++ programs begin to execute in the main method.,1.0
11,At the main function.,The main method.,1.0
12,A location in memory that can store a value.,"In programming, a structure that holds data and is uniquely named by the programmer. It holds the data assigned to it until a new value is assigned or the program is finished. ",0.9
13,A location in memory that can store a value.,A variable is a location in memory where a value can be stored.,1.0
14,A location in memory that can store a value.,A location in memory where value can be stored.,1.0
15,Variables can be declared anywhere in a program. They can be declared inside a function (local variables) or outside the functions (global variables),In the Function main() before using the variable.,0.6
16,Variables can be declared anywhere in a program. They can be declared inside a function (local variables) or outside the functions (global variables),"Local variables are declared inside the method or function they will be used in at the beginning of the method. Global variables are declared outside of any function or method, generally before functions are defined.",1.0
17,Variables can be declared anywhere in a program. They can be declared inside a function (local variables) or outside the functions (global variables),Inside the method.,0.5
18,The block inside a do...while statement will execute at least once.,do...while statements evaluate whether or not to loop after running the block contained within it at least once. So the main differance is that while statements have a possibility of never being used. Do ... while statements on the other hand are always run at least once before evaluating whether to run again.,1.0
19,The block inside a do...while statement will execute at least once.,"The main difference between a while and a do...while loop is that the do...while loop always cycles through the loop at least once, but the while loop does not always do so.",1.0
20,The block inside a do...while statement will execute at least once.,The loop of a do...while statement always executes once.,0.9
21,Data members (attributes) and member functions.,The attributes of said class. Also whether or not it is a subclass. Also whether it is public private or protected.,0.8
22,Data members (attributes) and member functions.,A class definition usually contains the function and its data members,1.0
23,Data members (attributes) and member functions.,"public section and private section, and there must be a semicolon to set the end",0.5
24,Data members can be accessed from any member functions inside the class defintion. Local variables can only be accessed inside the member function that defines them.,A field variable is a variable that is declared as a member of a class. A local variable is avariable that isdeclared local to a method.,0.5
25,Data members can be accessed from any member functions inside the class defintion. Local variables can only be accessed inside the member function that defines them.,Data members are the atributes of the function and can be used outside the function. Local variable can not be used outside the function and the value is lost after the function terminates.,0.9
26,Data members can be accessed from any member functions inside the class defintion. Local variables can only be accessed inside the member function that defines them.,"data member is accessible to all functions in the class, where local variable is only available to the member function and value is lost when function closes",1.0
27,"A constructor is called whenever an object is created, whereas a function needs to be called explicitely. Constructors do not have return type, but functions have to indicate a return type.","all constructors are functions but not all functions are constructors. Also functions can have nearly infinite purposes, while constructors always create an instance of whichever class you are using. You can change how a constructor does something but not what it does. With functions you can change not only the how but also the what.",0.6
28,"A constructor is called whenever an object is created, whereas a function needs to be called explicitely. Constructors do not have return type, but functions have to indicate a return type.",A constructor does not return any date and has no return type.  Functions can return date or not return data can have a return type.,0.8
29,"A constructor is called whenever an object is created, whereas a function needs to be called explicitely. Constructors do not have return type, but functions have to indicate a return type.",constructor creates the class object into memory where functions perform actions against that object,0.6
30,"If no constructor is provided, the compiler provides one by default. If a constructor is defined for a class, the compiler does not create a default constructor.",during compilation,0.7
31,"If no constructor is provided, the compiler provides one by default. If a constructor is defined for a class, the compiler does not create a default constructor.",When it the programs compiles,0.7
32,"If no constructor is provided, the compiler provides one by default. If a constructor is defined for a class, the compiler does not create a default constructor.",when no user-defined constructor exists,1.0
33,Unlimited number.,As many as you want so long as they have different parameters.,1.0
34,Unlimited number.,One,0.0
35,Unlimited number.,as many as wanted/needed,1.0
36,"A function prototype includes the function signature, i.e., the name of the function, the return type, and the parameters' type. The function definition includes the actual body of the function.","The FUNCTION PROTOTYPE is where the programmer declares that he/she is using a function other than main( ). This is like declaring a variable, the programmer knows that he/she will be using in the future, but has yet to say where they are going to use it, or how. This is answers the question who, it gives the function a name and character. The function prototype, by common practice is placed at the beginning of the program after the #includes and before main( ). The FUNCTION DEFINITION is the guts of the function. This is where the programmer decides what the function is going to do and tells it how to do it. It takes whatever information it is given and performs the operations. It works sort of like the brain, the brain takes in input and based upon that input performs in some way producing an output. The function defintion is placed outside of main( ) and any other functions. A function is its own entity and should be thought of as such.",0.5
37,"A function prototype includes the function signature, i.e., the name of the function, the return type, and the parameters' type. The function definition includes the actual body of the function.",Function prototype is located in the .h file and only contains the access function name and paramater type.  Function definition contains the code for the function to perform its activity.,0.9
38,"A function prototype includes the function signature, i.e., the name of the function, the return type, and the parameters' type. The function definition includes the actual body of the function.","prototype states all functions in that class before compilation, where the definition actually holds the source for the functions",0.7
39,"To store a class interface, including data members and member function prototypes.",The main role of header file is it is used to share information among various files.,0.6
40,"To store a class interface, including data members and member function prototypes.",Header files declares the class member functions.,0.7
41,"To store a class interface, including data members and member function prototypes.","to separate the source code from the main function, allows the methods/classes to be included in the program without direct coding. allows re usability.",0.7
42,The name of the function and the types of the parameters.,it includes the specific information about the function such as input and output variable types and how many of each.,0.6
43,The name of the function and the types of the parameters.,the name of the function and its parameters,1.0
44,The name of the function and the types of the parameters.,the name of the function and the types of its arguments,1.0
45,File scope.,they can be accessed by any C++ file anywhere.,0.5
46,File scope.,the whole code,0.9
47,File scope.,throughout the execution of the program,0.9
48,It makes a copy of the function code in every place where a function call is made.,"When the compiler inline-expands a function call, the function's code gets inserted into the caller's code stream (conceptually similar to what happens with a #define macro). This can, depending on a zillion other things, improve performance, because the optimizer can procedurally integrate the called code â€” optimize the called code into the caller.   ",0.9
49,It makes a copy of the function code in every place where a function call is made.,"instead of calling the function every time it is invoked, the compiler will replace the function call with a copy of the function body",1.0
50,It makes a copy of the function code in every place where a function call is made.,compiler ignores inline qualifier,0.5
51,It avoids making copies of large data structures when calling functions.,because you can't change the original and passing by reference limits memory needed for the program.,0.9
52,It avoids making copies of large data structures when calling functions.,"it takes less memory, thus it would make the program faster",0.8
53,It avoids making copies of large data structures when calling functions.,"large data items can be passed without copying the entire data point, reducing execution time and the amout of memory space needed ",1.0
54,"Based on the function signature. When an overloaded function is called, the compiler will find the function whose signature is closest to the given function call.",They differentiated by the compiler by the conditions/inputs used for one of the overloaded functions.,0.6
55,"Based on the function signature. When an overloaded function is called, the compiler will find the function whose signature is closest to the given function call.",paremeters,0.9
56,"Based on the function signature. When an overloaded function is called, the compiler will find the function whose signature is closest to the given function call.","it looks at the number, types, and order of arguments in the function call ",1.0
57,"If the recursion step is defined incorrectly, or if the base case is not included.",badly designed algorithyms. using recursion for a non recursive problem.,0.5
58,"If the recursion step is defined incorrectly, or if the base case is not included.",no base case or if the programmar does not define the base case as the simplest case and it never gets reached,1.0
59,"If the recursion step is defined incorrectly, or if the base case is not included.","Either omitting the base case, or writing the recursion step incorrectly so that it does not converge on the base case",1.0
60,They both involve repetition; they both have termination tests; they can both occur infinitely.,"As discussed earlier, recursion may be used to process iterative actions. Recursion is used for calculations where the answer can be described in a function that relates to itself.",0.4
61,They both involve repetition; they both have termination tests; they can both occur infinitely.,they are used to solve the same type of problems. they do a task over and over again until a cirtain conditional statement is reached (its called the base case in recursion).,0.7
62,They both involve repetition; they both have termination tests; they can both occur infinitely.,"they are both based on a control statement, both involve repetition, both involve a termination case, both graduatlly approach that termination case, and both can occur infinitely",1.0
63,"In the array declaration, or by using an initializer list.",by either inputing the different elements in the array at coding or giving the array specifacations as to the size of the array. it is also possible when giving it specifacations to tell the array to grow as needed.,0.8
64,"In the array declaration, or by using an initializer list.",statically and dynamically,0.5
65,"In the array declaration, or by using an initializer list.","Supply an integer inside the brackets or the compiler counts the number of elements in the initializer list. int n[5]; int n[] = { 1,2,3,4,5 }",1.0
66,The strings declared using an array of characters have a null element added at the end of the array.,"the type string uses less storage and you have to change the string all at once. with an array of characters you can make permutations of words using the characters stored in the array, without needing to actually access and change the variables. with an array of characters you can just change how they're accessed.",0.6
67,The strings declared using an array of characters have a null element added at the end of the array.,string is a class in the standard library and has method that modify it. Whereas the char array is on able to be modifie by the user.,0.8
68,The strings declared using an array of characters have a null element added at the end of the array.,Char array - Individual letters can be accessed directly with array subscript notation.  String array - array subscript will return the entire string.,0.4
69,by reference.,a reference pointer to an element in the array.,0.9
70,by reference.,you pass a pointer to the first item and also pass the size.,0.7
71,by reference.,"The function recieves both the array and the array size as parameters. function(arrayName, arraySize)",0.8
72,"The arrays declared as static live throughout the life of the program; that is, they are initialized only once, when the function that declares the array it is first called.",a static array can only be referenced not accessed. Also static arrays can be used without creating an object.,0.8
73,"The arrays declared as static live throughout the life of the program; that is, they are initialized only once, when the function that declares the array it is first called.",a static array has pre-runtime size and that size cannot be changed. A dynamic array gets its size at runtime.,0.6
74,"The arrays declared as static live throughout the life of the program; that is, they are initialized only once, when the function that declares the array it is first called.","Static arrays are created and initialized only once, and the values aren't destroyed  when the function terminates in the program. Automatic arrays reset everytime the function is called.",1.0
75,"All the dimensions, except the first one.",all of them.,0.7
76,"All the dimensions, except the first one.",just the first one at least.,0.4
77,"All the dimensions, except the first one.","None, just pass the array name.",0.4
78,"Taking one array element at a time, from left to right, it inserts it in the right position among the already sorted elements on its left.","Insertion sort divides the list into sorted and unsorted regions, then takes each item from the unsorted region and inserts it into its correct order in the sorted region.",1.0
79,"Taking one array element at a time, from left to right, it inserts it in the right position among the already sorted elements on its left.",The sorted array or list is built one entry at a time.,0.7
80,"Taking one array element at a time, from left to right, it inserts it in the right position among the already sorted elements on its left.",insertion sort is were after k iterations the first k items in the array are sorted it take the k+1 item and inserts it into the correct position in the already sorted k elements.,0.9
81,"Taking one array element at a time, from left to right, it identifies the minimum from the remaining elements and swaps it with the current element.","Selection sort searches the whole array for the largest item and puts it at the end of the array, then searches for the second largest item and puts it at the second to last spot and so on.",0.9
82,"Taking one array element at a time, from left to right, it identifies the minimum from the remaining elements and swaps it with the current element.",Finds the minimum value and swap it with the value in the first position.,1.0
83,"Taking one array element at a time, from left to right, it identifies the minimum from the remaining elements and swaps it with the current element.",find the minimum value in the list swap it with the first element in the list the find the second largest and swap it with the second element in the array continue like this until  the array is sorted.,1.0
84,N (the length of the array) operations achieved for a sorted array.,"Insertion sort is O(n) and performs n-1 operations in the best-case scenario, which is when the list or array is already sorted.",0.9
85,N (the length of the array) operations achieved for a sorted array.,"The number of operations for insertions sort, under best-case, is  n(n-1)/2. The best case for insertion sort is on a sorted list where it runs is O(n). ",0.6
86,N (the length of the array) operations achieved for a sorted array.,O(n),0.7
87,When the size of the array to be sorted is 1 (or 2),The base case for a recursive implementation of merge sort is when the sequence being passed to merge sort has less than 2 elements.,1.0
88,When the size of the array to be sorted is 1 (or 2),The base case for a recursive implementation of merge sort is one.,1.0
89,When the size of the array to be sorted is 1 (or 2),O(nlog(n)),0.5
90,A variable that contains the address in memory of another variable.,Is a reference call to the place in memory where the object is stored.,0.8
91,A variable that contains the address in memory of another variable.,"A pointer variable contains the number of a memory address as its value, which may be null or 0, or the address of some value stored in memory.",1.0
92,A variable that contains the address in memory of another variable.,Pointers are variables that contain as their values memory addresses of other variables.,1.0
93,The memory address of its operand.,memory address of its operand,1.0
94,The memory address of its operand.,"It returns the memory address of it's operand. That is, if applied to a normal variable, it gives the variable's memory address, just as a pointer variable might.",0.9
95,The memory address of its operand.,The address (&) operator returns the memory address of its operand.,1.0
96,An alias (synonym) for the name of the object that its operand points to in memory. It is the dereferencing operator.,synonym for the object its operand points to,1.0
97,An alias (synonym) for the name of the object that its operand points to in memory. It is the dereferencing operator.,"It dereferences a pointer, meaning it returns the value stored in the memory address a pointer refers to.",0.9
98,An alias (synonym) for the name of the object that its operand points to in memory. It is the dereferencing operator.,"It returns a synonym, alias or nickname of the name of the object that its operand points to in memory (dereferencing the pointer).",1.0
99,"By initializing a pointer to point to the first element of the array, and then incrementing this pointer with the index of the array element.",Element A[n] can be accessed by *(APtr + n),0.8
100,"By initializing a pointer to point to the first element of the array, and then incrementing this pointer with the index of the array element.","First, some pointer variable must reference the first entity in the array. Any variable in the array can then be accessed by referring to that first entity's address plus some offset. i.e. ptrToArray = array;  nthEntity = *(ptrToArray + n);",1.0
101,"By initializing a pointer to point to the first element of the array, and then incrementing this pointer with the index of the array element.",Using either the name of the array as a pointer or using a separate pointer that points to the array.,0.6
102,The size in bytes of its operand.,the size of operand in bytes,1.0
103,The size in bytes of its operand.,"It returns the size of an operand in memory, which is checked at compiler-time.",0.8
104,The size in bytes of its operand.,It returns the size of an array in bytes.,0.9
105,"There are four ways: nonconstant pointer to constant data, nonconstant pointer to nonconstant data, constant pointer to constant data, constant pointer to nonconstant data.","constant pointer to constant data, constant pointer to nonconstant data, nonconstant pointer to constant data, nonconstant pointer to nonconstant data",1.0
106,"There are four ways: nonconstant pointer to constant data, nonconstant pointer to nonconstant data, constant pointer to constant data, constant pointer to nonconstant data.","Pointers may be passed to functions by value, by reference with reference arguments, or by reference with pointer arguments.",0.5
107,"There are four ways: nonconstant pointer to constant data, nonconstant pointer to nonconstant data, constant pointer to constant data, constant pointer to nonconstant data.","Four different ways: Nonconstant pointer to nonconstant data, a nonconstant pointer to constant data, a constant pointer to nonconstant data and a constant pointer to constant data.",1.0
108,The address of the location in memory where the function code resides.,is a pointer that contains the address of a function,1.0
109,The address of the location in memory where the function code resides.,"A function pointer contains the memory address of a function. Using a function pointer, a function can be passed to or returned by another function. Function pointers can also be stored in arrays.",1.0
110,The address of the location in memory where the function code resides.,"A pointer to a function is the address where the code for the function resides. They can be passed to functions, returned from functions, stored in arrays and assigned to other pointers.",1.0
111,A collection of elements that can be allocated dynamically.,a series of structures containing data items and a pointer that links the structure to the next structure.,0.9
112,A collection of elements that can be allocated dynamically.,A link list is a data structure which is built from structures and pointers. It forms a chain of nodes with pointers representing the links of the chain and holding the entire thing together,0.8
113,A collection of elements that can be allocated dynamically.,"A list of elements, or nodes, that are linked to one another such that each element points to the next element.",0.9
114,The linked lists can be of variable length.,more memory can be allocated on the fly for more items,0.9
115,The linked lists can be of variable length.,"Array has a fixed size, but linked list is able to grow in size as needed",1.0
116,The linked lists can be of variable length.,You can insert into and delete items from a pointer-based linked list without shifting data.,0.9
117,"The elements in an array can be accessed directly (as opposed to linked lists, which require iterative traversal).",link lists only allow sequential access where arrays allow random access,0.9
118,"The elements in an array can be accessed directly (as opposed to linked lists, which require iterative traversal).",Array based implementation requires less memory than lined lists based implementation,0.7
119,"The elements in an array can be accessed directly (as opposed to linked lists, which require iterative traversal).",Arrays are good for random access and good for sequential access which are both in constant time. Where linked lists are linear for random access. Arrays are faster in this case.,1.0
120,By reference.,the pointer to the first element is passed to a function,0.8
121,By reference.,Pass the head pointer to a function as a reference argument,1.0
122,By reference.,By using a node.,0.5
123,The last element in a circular linked list points to the head of the list.,in a circular linked list the last element points to the head of the list,1.0
124,The last element in a circular linked list points to the head of the list.,"In circular linked list each node has successor, no node contains NULL, while in basic linked list last node contain NULL.",0.6
125,The last element in a circular linked list points to the head of the list.,"In a circular linked list, the last node points to the first node.",1.0
126,"All the deletion and insertion operations can be performed in constant time, including those operations performed before a given location in the list or at the end of the list.",a doubly linked list has pointers in both directions. this allows for access from back to front as well as front to back,0.8
127,"All the deletion and insertion operations can be performed in constant time, including those operations performed before a given location in the list or at the end of the list.","Double Linked list are often easier to manipulate, because they allow sequential access to the list in both direction",0.8
128,"All the deletion and insertion operations can be performed in constant time, including those operations performed before a given location in the list or at the end of the list.",A doubly linked list allows you to traverse the list in either direction. Each node points to its successor as well as to its predecessor.,0.7
129,Extra space required to store the back pointers.,"in a doubly linked list there are twice as many pointers for each element , therefore more memory is used",1.0
130,Extra space required to store the back pointers.,"Double linked lists require more space per node, and their elementary operation are more expensive",1.0
131,Extra space required to store the back pointers.,Insertion and deletion with a doubly linked list are more involved than with a singly linked list leaving more room for error and complex algorithms.,0.6
132,"A data structure that can store elements, which has the property that the last item added will be the first to be removed (or last-in-first-out)",Stores a set of elements in a particular order.,0.4
133,"A data structure that can store elements, which has the property that the last item added will be the first to be removed (or last-in-first-out)","An ADT whose most recently inserted item is the first item removed or retrieved. This property is called last in, first out (LIFO). Items enter and leave a stack at its top.",1.0
134,"A data structure that can store elements, which has the property that the last item added will be the first to be removed (or last-in-first-out)","A stack is similar to an array, but does not allow for random access. Stacks only allow a user to retrieve the last item put into the stack. Last in, fist out.",1.0
135,push and pop,Push and pop.,1.0
136,push and pop,Pop function and Push function,1.0
137,push and pop,Push (insert) and pop (retrieve).,1.0
138,"Keep the top of the stack toward the end of the array, so the push and pop operations will add or remove elements from the right side of the array.","If you use a dynamically allocated array, you must provide a destructor and copy constructor.",0.6
139,"Keep the top of the stack toward the end of the array, so the push and pop operations will add or remove elements from the right side of the array.","Create a int value that stores the ""head"" of the stack. Increment the top when one element is pushed and decrement after it is popped.",1.0
140,"Keep the top of the stack toward the end of the array, so the push and pop operations will add or remove elements from the right side of the array.","Declare a variable that points the last item in the array, which increases (++) when items are pushed onto the stack, and decreases (--) when an item is popped off the top.",1.0
141,"Keep the top of the stack pointing to the head of the linked list, so the push and pop operations will add or remove elements at the beginning of the list.",This is the implementation of the stack using single linked list.   The operations performed on a stack are    1)push(): This is the function which is for insertion(pushing)of an element into stack                      It is similar to the insertion of an element at the end of a single linked list                   see  the function insert_end() in the program for operations of single linked list    2)pop(): This is the function which is for deletion(popping up) of an element from the stack             It is similar to the deletion of an element at the end of a single linked list       see  the function delete_end() in the program for operations of single linked list    3)stack_display():This is the function which is for displaying the elements of a stack,0.8
142,"Keep the top of the stack pointing to the head of the linked list, so the push and pop operations will add or remove elements at the beginning of the list.",Using nodes to keep track of the head of the stack. Then using Push( ) and Pop ( ) to create the stack as needed.,0.8
143,"Keep the top of the stack pointing to the head of the linked list, so the push and pop operations will add or remove elements at the beginning of the list.","Declare a pointer that points to the head of the linked list, only add and remove nodes from the beginning of the list.",1.0
144,"First, they are converted into postfix form, followed by an evaluation of the postfix expression.","Computers cannot evaulate infix expressions, it must first convert infix to postfix expression then it can evaluate.",1.0
145,"First, they are converted into postfix form, followed by an evaluation of the postfix expression.",By using parentheses to have order in the expression.,0.5
146,"First, they are converted into postfix form, followed by an evaluation of the postfix expression.",Infix expressions are interpreted as postfix expressions by implementing stacks.,1.0
147,"Pop all the elements and store them on another stack until the element is found, then push back all the elements on the original stack.",Push adds a given node to the top of the stack leaving previous nodes below. Pop removes and returns the current top node of the stack.,0.6
148,"Pop all the elements and store them on another stack until the element is found, then push back all the elements on the original stack.","Using linked lists and stacks, you would need a temp stack to retain the values. Then you would use the Pop( ) function to pop off each element and then compare it. If its not the element your looking for, Push ( ) it to the temp stack. Repeat until the element is found. When you find it,  Pop ( ) off the temp stack back onto the regular stack to have a complete stack again.",1.0
149,"Pop all the elements and store them on another stack until the element is found, then push back all the elements on the original stack.","Pop an element from one stack, check to see if it is the desired element, if not push it onto another stack. When finished, pop the items from the second stack and push them back onto the first stack (this will ensure the order of the elements is maintained).",1.0
150,"A data structure that can store elements, which has the property that the last item added will be the last to be removed (or first-in-first-out).",A queue is an abstract data structure in which operations are performed at both ends giving the queue first in first out behavior.,1.0
151,"A data structure that can store elements, which has the property that the last item added will be the last to be removed (or first-in-first-out).","A queue stores a set of elements in a particular order.  Its principle of operation is FIFO(first in first out), which means the first element inserted is the first one to be removed.",1.0
152,"A data structure that can store elements, which has the property that the last item added will be the last to be removed (or first-in-first-out).",A waiting list of items that operation in a FIFO (first in first out) order.,1.0
153,enqueue and dequeue,The two main functions are enqueue which inserts an item at the back of the queue and dequeue which removes an item from the front of the queue.,1.0
154,enqueue and dequeue,The two main functions are enqueue and dequeue.,1.0
155,enqueue and dequeue,"Remove the item added first, add items to the back.",1.0
156,"Use a circular array. Keep the rear of the queue toward the end of the array, and the front toward the beginning, and allow the rear pointer to wrap around.",By implementing an array and only adding items to the end of the array and only removing items from the beginning of the array.,0.6
157,"Use a circular array. Keep the rear of the queue toward the end of the array, and the front toward the beginning, and allow the rear pointer to wrap around.","For applications in which a fixed-sized queue does not present a problem, you can use an array to represent a queue. ",0.5
158,"Use a circular array. Keep the rear of the queue toward the end of the array, and the front toward the beginning, and allow the rear pointer to wrap around.",Utilizing indexes for the front and the back.  Front is 0 and as you add items the back index is incremented.,0.8
159,"Keep the rear of the queue pointing to the tail of the linked list, so the enqueue operation is done at the end of the list, and keep the front of the queue pointing to the head of the linked list, so the dequeue operation is done at the beginning of the list.","By implementing a list in which a tail pointer points to the item most recently inserted onto the back of the list and a head pointer which points to the item least recently inserted onto the list. Also, items can only be removed from the front of the list and can only be added to the back of the list.",1.0
160,"Keep the rear of the queue pointing to the tail of the linked list, so the enqueue operation is done at the end of the list, and keep the front of the queue pointing to the head of the linked list, so the dequeue operation is done at the beginning of the list.",You can use list to represent the items in a queue.,0.3
161,"Keep the rear of the queue pointing to the tail of the linked list, so the enqueue operation is done at the end of the list, and keep the front of the queue pointing to the head of the linked list, so the dequeue operation is done at the beginning of the list.","Utilizing a front pointer and a back pointer.  The front poiner and back pointer points to the first item into the queue.  As you add items, the front remains the same but the back poiner 'next' points to the new item and the new item is assigned to become the 'new' back pointer.",0.9
162,push,The stack operation corresponding to enqueue in queues is the push operation.,1.0
163,push,"Push in a stack operation corresponds to the enqueue operation in queues.  These operations insert a new item into one end(the top and back, respectively) of the ADT.",1.0
164,push,Not sure what this question means.  You can use the stack 'push' operation and the enqueue operation to detect palindromes.,1.0
165,"A collection of nodes, which has a special node called root, and the rest of the nodes are partitioned into one or more disjoint sets, each set being a tree.","A finite number of nodes such that there is one root node, each node has a certain number of children nodes, and each child is also a tree",1.0
166,"A collection of nodes, which has a special node called root, and the rest of the nodes are partitioned into one or more disjoint sets, each set being a tree.","a finite collection of nodes, where it starts with an element called the root, which has children, and its children have children until you get to the leaves which are the last elements and have to children",0.9
167,"A collection of nodes, which has a special node called root, and the rest of the nodes are partitioned into one or more disjoint sets, each set being a tree.","A connected, undirected graph without cycles.",0.9
168,The length of the longest path from the root to any of its leaves.,the height of a tree is how many levels of nodes that it has,0.9
169,The length of the longest path from the root to any of its leaves.,is the number of generations in the tree,0.9
170,The length of the longest path from the root to any of its leaves.,The number of nodes on the longest path from the root of the tree to a leaf.,1.0
171,A node that has no children.,a leaf is a node with no children,1.0
172,A node that has no children.,an element in a tree that has no children,1.0
173,A node that has no children.,A tree node with no children.,1.0
174,A tree for which the maximum number of children per node is two.,a binary tree is a special type of tree where each node can only have at maximum 2 children,1.0
175,A tree for which the maximum number of children per node is two.,a tree where every parent has only two children,0.9
176,A tree for which the maximum number of children per node is two.,"A set of zero or more nodes, partitioned into a root node and two possibly empty sets that are binary trees. Thus, each node in a binary tree has at most two children, the left child and the right child.",1.0
177,A binary tree that has the property that for any node the left child is smaller than the parent which in turn is smaller than the right child.,"it is a binary tree where each node has a unique key, the left child of a node has only values less than that node, and the right child of each node has higher values than that node.",1.0
178,A binary tree that has the property that for any node the left child is smaller than the parent which in turn is smaller than the right child.,"a binary tree with a special organization of data. where the left child of the element is less than it, and the right child is larger than it.",1.0
179,A binary tree that has the property that for any node the left child is smaller than the parent which in turn is smaller than the right child.,"A binary tree where the search key in any node n is greater than the search key in any node in n's left subtree, but less than the search key in any node in n's right subtree.",1.0
180,"Traverse the left subtree, then the root, then the right subtree.","it means that you traverse one subtree of a node, then look at the node itself before traversing the other subtree of the node",0.8
181,"Traverse the left subtree, then the root, then the right subtree.",left middle right,1.0
182,"Traverse the left subtree, then the root, then the right subtree.",Its used to visit nodes of a binary search tree in a search key order.,0.7
183,The height of the tree (or log of the number of elements in the tree).,"it takes h comparisons, where h is the height of the tree",1.0
184,The height of the tree (or log of the number of elements in the tree).,O(log n),1.0
185,The height of the tree (or log of the number of elements in the tree).,At most its equivalent to the height of the tree.,1.0
186,Function members and data members.,"access specifiers and functions, oftentimes a constructor.",0.6
187,Function members and data members.,return type and input parameters,0.4
188,Function members and data members.,functions and data members,1.0
189,"It splits the original array into two, sorts each of the two halves, and then merges the sorted arrays.",A merge sort works by removing all items to sepperate memory locations and merging them back together in order.,0.7
190,"It splits the original array into two, sorts each of the two halves, and then merges the sorted arrays.",merge sort splits the array of elements into smaller arrays until the arrays reach size 1 and then the merge sort merges the smaller arrays into arrays of size 2 then it moves to the next step and merges the next arrays.,1.0
191,"It splits the original array into two, sorts each of the two halves, and then merges the sorted arrays.",Mergesort divides the array into smaller halves and then combines the sorted subarrays into one sorted array.,1.0
192,Private and public.,"Public, Private, Restricted",0.925
193,Private and public.,public private and protected,0.975
194,Private and public.,"private, public",1.0
195,By using constructors.,They are initialized as a named instance of the template formed by the class. This named instance can then be modified to be different from the class that it was created from.,0.675
196,By using constructors.,classname objectname(input parameters);,0.55
197,By using constructors.,"The value is specified after declaration,  It can initialized anywhere between the declaration and the corresponding }.",0.475
198,"The name of the function and the list of parameters, including their types.",a function signature is the elements that make it unique such as the variables it calls for and also I suppose this includes the program it is in.,0.75
199,"The name of the function and the list of parameters, including their types.",its return type and its input parameters,1.0
200,"The name of the function and the list of parameters, including their types.","The order, number, and type of data items included inside the function parameters.",0.95
201,A function that calls itself.,A function that calls itself to perform an opperation such as a factorial recursive function.,1.0
202,A function that calls itself.,a function that calls itself until a base case is met,1.0
203,A function that calls itself.,A recursive function only knows how to solve base cases  A recursive function calls itself directly or indirectly until a base case is reached.,1.0
204,Through iteration.,The alternative method is to use loops in the program instead of a function which calls itself.,0.75
205,Through iteration.,you can also solve the problem iteratively,1.0
206,Through iteration.,Iteration.,1.0
207,The static arrays are intialized only once when the function is called.,A static array only has a specific size and it cannot grow. Also static arrays cannot be accessed outside the program which created it.,0.575
208,The static arrays are intialized only once when the function is called.,a static array has a predetermined size and that size cannot be altered,0.575
209,The static arrays are intialized only once when the function is called.,A static array retains any modified values after a function call. Automatic arrays reset to their initial values when the function ends.,0.875
210,The char[] will automatically add a null \0 character at the end of the string.,a variable char is basically any non command key on the keyboard that you can press. A string is a collection of letters or numbers that is stored together to be used later. Comonly strings are used for words. Chars can be used for less but can have opperations performed on them in a useful way.,0.375
211,The char[] will automatically add a null \0 character at the end of the string.,an array of characters stores a null character at the end,1.0
212,The char[] will automatically add a null \0 character at the end of the string.,a string char[] adds a null value to the end of the string.,1.0
213,"Divide a problem into smaller subproblems, solve them recursively, and then combine the solutions into a solution for the original problem.",Divide and coquer means dividing a problem into 2+ problems which are solved and then merged  back together for a final solution to the whole problem.,1.0
214,"Divide a problem into smaller subproblems, solve them recursively, and then combine the solutions into a solution for the original problem.",dived and conquer is the breaking up of a large complex program into small easy to solve components.,0.85
215,"Divide a problem into smaller subproblems, solve them recursively, and then combine the solutions into a solution for the original problem.",It divides the problem into singular units and works on the problem piece by piece until the problem is solved.,0.85
216,The address of a location in memory.,A pointer is a variable that contains the memory address of a given value.,0.95
217,The address of a location in memory.,A pointer is a variable that stores the address of another variable.,1.0
218,The address of a location in memory.,A pointer is a variable that points to the address location of another variable.  Represented by (*).,1.0
219,The height of the tree.,log(n) steps,0.95
220,The height of the tree.,The number of levels and the height of the tree,1.0
221,The height of the tree.,Depends on the location of the node you are looking for. If it is the root it is one step.  else If it is smaller than the current you are on node you go to the left.  If it is larger than the current node you are on go to the right.,0.375
222,Implement the algorithm and measure the physical running time.,not answered,0.0
223,Implement the algorithm and measure the physical running time.,time complexity using big O  logarthmic O(log n) linear O(n) exponential O(n^2) quadratic O(n^k) k&gt;=1 Polynomial O(a^n) n&gt;1,0.45
224,Implement the algorithm and measure the physical running time.,"Oposite of a theoretical assessment of the algorithm to determine runtime, but to run the code first to determine the the runtime.  This is not recommended because it is a limited test.  It does not include all possibilities of the data, nor the hardware used to process the data.",0.925
225,"It selects the minimum from an array and places it on the first position, then it selects the minimum from the rest of the array and places it on the second position, and so forth.","Selection sort searches the array for the lowest value and swaps it with the first value in the array. Then searches for the next lowest value and swaps it with the second item in the array, and so on.",1.0
226,"It selects the minimum from an array and places it on the first position, then it selects the minimum from the rest of the array and places it on the second position, and so forth.",Compare the largest element to the front element and swap data according to value if needed.,0.775
227,"It selects the minimum from an array and places it on the first position, then it selects the minimum from the rest of the array and places it on the second position, and so forth.",You select the smallest element and place it on the left.  You select the smallest element and sort it with respect the the item already on the left.  You continue this till the end of the collection of items.,1.0
228,"Linked lists are dynamic structures, which allow for a variable number of elements to be stored.",The advantage of linked lists is that they are not limited in size like arrays.,1.0
229,"Linked lists are dynamic structures, which allow for a variable number of elements to be stored.",link lists dont have a fixed size,1.0
230,"Linked lists are dynamic structures, which allow for a variable number of elements to be stored.",You do not have to predetermine your list size as you do with arrays. Linked list have the ability to be as large as you want them adding memory as needed.,1.0
231,A data structure that stores elements following the first in first out principle. The main operations in a queue are enqueue and dequeue.,A queue is an abstract data type that performs operations on both ends of the list and exhibits first-in first-out behavior.,1.0
232,A data structure that stores elements following the first in first out principle. The main operations in a queue are enqueue and dequeue.,First in first out.,0.9
233,A data structure that stores elements following the first in first out principle. The main operations in a queue are enqueue and dequeue.,A queue is a collection of elements with the characteristics of first in first out (FIFO).  The first item in is the first item out.  All additional items are added to the end of the list.,1.0
234,push and pop,"Pop, which removes the head, or least recently inserted node from the stack. Push, which inserts a new node at the head of the stack.",1.0
235,push and pop,Push and pop,1.0
236,push and pop,Push  and pop.,1.0
237,"A walk around the tree, starting with the root, where each node is seen three times: from the left, from below, from the right.","The Euler tour traversal of a tree begins at the root and visits each node in the tree from the left, then bottom, then right sides.",1.0
238,"A walk around the tree, starting with the root, where each node is seen three times: from the left, from below, from the right.",Where you visit the in order according to its data value.,0.55
239,"A walk around the tree, starting with the root, where each node is seen three times: from the left, from below, from the right.","To start from the root , traveling left and visiting ever child along the way till you return to the root from the right.",0.825
240,"Find the node, then replace it with the leftmost node from its right subtree (or the rightmost node from its left subtree).","Traverse the tree and find the node, if the node has no children, simply delete it; otherwise set the node's data equal to the data of one of its children then set the pointer for that child to NULL.",0.675
241,"Find the node, then replace it with the leftmost node from its right subtree (or the rightmost node from its left subtree).",first attaching the elements from the node to be deleting to alternate nodes and then deleting that node.    delete node;,0.675
242,"Find the node, then replace it with the leftmost node from its right subtree (or the rightmost node from its left subtree).","You traverse the tree till you find the node you are wanting to delete.  If the node has no children you delete it.  If the node has children, before you delete, you find the left-most of its children and attach it to the root then you can delete the node.",0.775
